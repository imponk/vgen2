<!DOCTYPE html>
<html lang="id">
<head>
  <meta charset="UTF-8">
  <title>Reels – Upper / Judul / Subjudul / Isi (Final – Kerning + Wrap + Wipe)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <!-- Google Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=DM+Serif+Display&family=Plus+Jakarta+Sans:wght@400;600;700&display=swap" rel="stylesheet">

  <style>
    * { box-sizing: border-box; }

    body {
      margin: 0;
      padding: 16px;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
        sans-serif;
      background: #0f172a;
      color: #e5e7eb;
      display: flex;
      gap: 16px;
    }
    .panel {
      background: #020617;
      border-radius: 12px;
      padding: 16px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.5);
    }
    .left {
      width: 360px;
      flex-shrink: 0;
    }
    .right {
      flex: 1;
      display: flex;
      justify-content: center;
      align-items: center;
    }
    h2 {
      margin: 0 0 6px 0;
      font-size: 18px;
    }
    small {
      font-size: 11px;
      color: #9ca3af;
    }
    .field {
      margin-top: 12px;
    }
    label {
      font-size: 13px;
      display: block;
      margin-bottom: 4px;
      color: #9ca3af;
    }
    textarea {
      width: 100%;
      border-radius: 8px;
      border: 1px solid #1f2937;
      background: #020617;
      color: #e5e7eb;
      padding: 8px 10px;
      font-size: 14px;
      outline: none;
      resize: vertical;
      min-height: 50px;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
        sans-serif;
    }
    textarea:focus {
      border-color: #2563eb;
    }
    .btn-row {
      display: flex;
      gap: 8px;
      margin-top: 12px;
      flex-wrap: wrap;
    }
    button {
      border: none;
      border-radius: 999px;
      padding: 8px 16px;
      font-size: 14px;
      cursor: pointer;
      font-weight: 500;
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }
    .btn-primary { background: #2563eb; color: white; }
    .btn-secondary { background: #111827; color: #e5e7eb; }
    .btn-danger { background: #b91c1c; color: #fee2e2; }
    button:disabled { opacity: 0.6; cursor: default; }

    .status {
      margin-top: 8px;
      font-size: 12px;
      color: #9ca3af;
    }
    .download-link { margin-top: 8px; font-size: 13px; }

    canvas {
      background: #9a9a9a;
      border-radius: 18px;
      border: 1px solid #4b5563;
      box-shadow: 0 20px 40px rgba(0,0,0,0.65);
      max-height: 92vh;
    }
  </style>
</head>
<body>
  <div class="panel left">
    <h2>Reels – Upper / Judul / Subjudul / Isi</h2>
    <small>
      Upper + Judul + Subjudul: <b>fade-in bersama</b>, lalu diam.<br>
      Isi: dipisah per halaman dengan <b>1 baris kosong</b>, tampil dengan
      <b>fade-in + sapuan dari kiri ke kanan</b> dan durasi otomatis berdasarkan panjang karakter.
      Plus Jakarta Sans tetap dipakai dengan kerning dijaga.
    </small>

    <div class="field">
      <label>Upper (opsional, gaya seperti subjudul)</label>
      <textarea id="upperInput" placeholder="Contoh: Warga Keluhkan Kemacetan di Menganti"></textarea>
    </div>

    <div class="field">
      <label>Judul Utama</label>
      <textarea id="titleInput" placeholder="Judul utama berita (paling besar)"></textarea>
    </div>

    <div class="field">
      <label>Subjudul (opsional)</label>
      <textarea id="subtitleInput" placeholder="Subjudul / kalimat pendukung"></textarea>
    </div>

    <div class="field">
      <label>Isi Berita</label>
      <textarea
        id="bodyInput"
        placeholder="Contoh format:\n\nIni isi 1 baris 1.\nIni isi 1 baris 2 [[dengan highlight]].\n\nIni isi 2 baris 1.\nIni isi 2 baris 2.\n\nIni isi 3 baris 1 saja."
      ></textarea>
    </div>

    <div class="btn-row">
      <button class="btn-secondary" id="previewBtn">Preview</button>
      <button class="btn-primary" id="recordBtn">Render Video</button>
      <button class="btn-danger" id="stopBtn" disabled>Stop</button>
    </div>

    <div class="status" id="statusText">Status: idle</div>
    <div class="download-link" id="downloadContainer"></div>
  </div>

  <div class="panel right">
    <canvas id="reelCanvas" width="1080" height="1920"></canvas>
  </div>

  <script>
    const canvas = document.getElementById("reelCanvas");
    const ctx = canvas.getContext("2d");

    const upperInput = document.getElementById("upperInput");
    const titleInput = document.getElementById("titleInput");
    const subtitleInput = document.getElementById("subtitleInput");
    const bodyInput = document.getElementById("bodyInput");

    const previewBtn = document.getElementById("previewBtn");
    const recordBtn = document.getElementById("recordBtn");
    const stopBtn = document.getElementById("stopBtn");
    const statusText = document.getElementById("statusText");
    const downloadContainer = document.getElementById("downloadContainer");

    let animating = false;
    let recording = false;
    let mediaRecorder = null;
    let recordedChunks = [];
    let startTime = null;
    let targetDuration = 12;

    // halaman isi: array halaman, tiap halaman = array baris
    let bodyPages = [];
    let pageDurations = [];   // durasi per halaman isi (detik)

    // Konstanta animasi judul & jeda
    const TITLE_FADE_IN = 0.8;        // durasi fade-in judul block
    const TITLE_STATIC_AFTER = 2.2;   // durasi diam setelah fade-in (total judul ~3 detik)
    const GAP_AFTER_TITLE = 1.0;      // jeda abu sebelum isi

    function setStatus(text) {
      statusText.textContent = "Status: " + text;
    }

    // --- helper: wrap text sederhana (judul/subjudul/upper) ---
    function wrapText(ctx, text, maxWidth) {
      const words = text.split(" ");
      const lines = [];
      let line = words[0] || "";

      for (let i = 1; i < words.length; i++) {
        const testLine = line + " " + words[i];
        if (ctx.measureText(testLine).width > maxWidth) {
          lines.push(line);
          line = words[i];
        } else {
          line = testLine;
        }
      }
      lines.push(line);
      return lines;
    }

    // Tokenize teks dengan [[highlight]] -> array token {text, highlight}
    function tokenizeHighlighted(text) {
      let tokens = [];
      let current = "";
      let inHighlight = false;
      let i = 0;

      function pushCurrent() {
        if (current.length > 0) {
          tokens.push({ text: current, highlight: inHighlight });
          current = "";
        }
      }

      while (i < text.length) {
        if (!inHighlight && text.startsWith("[[", i)) {
          pushCurrent();
          inHighlight = true;
          i += 2;
        } else if (inHighlight && text.startsWith("]]", i)) {
          pushCurrent();
          inHighlight = false;
          i += 2;
        } else {
          const ch = text[i];
          current += ch;
          if (ch === " ") {
            pushCurrent();
          }
          i++;
        }
      }
      pushCurrent();
      return tokens;
    }

    // Gambar satu "visual line" dari kumpulan token, dengan highlight, kerning utuh
    function drawLineFromTokens(ctx, tokens, x, y, normalColor, highlightColor, highlightBg) {
      let clean = "";
      for (const tok of tokens) {
        clean += tok.text;
      }

      // highlight rects
      let index = 0;
      for (const tok of tokens) {
        const text = tok.text;
        const len = text.length;
        if (tok.highlight && text.trim().length > 0) {
          const before = clean.slice(0, index);
          const inside = clean.slice(index, index + len);

          const wBefore = ctx.measureText(before).width;
          const wInside = ctx.measureText(inside).width;

          const rectX = x + wBefore - 4;
          const rectY = y - 40;
          const rectH = 52;

          ctx.fillStyle = highlightBg;
          ctx.fillRect(rectX, rectY, wInside + 8, rectH);
        }
        index += len;
      }

      // teks sekali saja
      ctx.fillStyle = normalColor;
      ctx.fillText(clean, x, y);
    }

    // Gambar paragraf isi: wrap ke beberapa visual line, kerning aman
    function drawWrappedRichParagraph(ctx, text, x, yStart, maxWidth, lineGap, normalColor, highlightColor, highlightBg) {
      const tokens = tokenizeHighlighted(text);
      let lines = [];
      let currentTokens = [];
      let currentText = "";

      for (const tok of tokens) {
        const proposedText = currentText + tok.text;
        const w = ctx.measureText(proposedText).width;

        if (currentText && w > maxWidth) {
          // commit line lama
          lines.push(currentTokens);
          currentTokens = [tok];
          currentText = tok.text;
        } else {
          currentTokens.push(tok);
          currentText = proposedText;
        }
      }
      if (currentTokens.length > 0) {
        lines.push(currentTokens);
      }

      let y = yStart;
      for (const lineTokens of lines) {
        drawLineFromTokens(ctx, lineTokens, x, y, normalColor, highlightColor, highlightBg);
        y += lineGap;
      }
      return y;
    }

    // background polos abu
    function drawBaseBackground() {
      const W = canvas.width;
      const H = canvas.height;
      ctx.fillStyle = "#9a9a9a";
      ctx.fillRect(0, 0, W, H);
    }

    // Slide 1: Upper / Judul / Subjudul dengan fade-in semua, lalu statis
    function drawSlide1(t, sceneDur) {
      const W = canvas.width;
      const H = canvas.height;
      drawBaseBackground();

      const marginLeftBase = 110;
      const marginRight = 140;
      const textWidth = W - marginLeftBase - marginRight;
      let y = H - 560;

      const upper = upperInput.value.trim();
      const title = titleInput.value.trim();
      const subtitle = subtitleInput.value.trim();

      const totalTitleTime = TITLE_FADE_IN + TITLE_STATIC_AFTER;
      const tLocal = Math.min(t, totalTitleTime);

      let alpha = 1;
      if (tLocal <= TITLE_FADE_IN) {
        const progress = Math.max(0, Math.min(tLocal / TITLE_FADE_IN, 1));
        const ease = progress * progress * (3 - 2 * progress);
        alpha = ease;
      } else {
        alpha = 1;
      }

      const marginLeft = marginLeftBase;

      ctx.globalAlpha = alpha;
      ctx.textAlign = "left";

      // Upper
      if (upper) {
        ctx.font = "700 28px 'Plus Jakarta Sans', system-ui";
        ctx.fillStyle = "#ffffff";
        const linesUpper = wrapText(ctx, upper, textWidth);
        const lhUpper = 30;
        for (const line of linesUpper) {
          ctx.fillText(line, marginLeft, y);
          y += lhUpper;
        }
        y += 10;
      }

      // Judul
      if (title) {
        ctx.font = "400 104px 'DM Serif Display', serif";
        ctx.fillStyle = "#ffffff";
        const linesTitle = wrapText(ctx, title, textWidth);
        const lhTitle = 104;
        for (const line of linesTitle) {
          ctx.fillText(line, marginLeft, y);
          y += lhTitle;
        }
        y += 10;
      }

      // Subjudul
      if (subtitle) {
        ctx.font = "700 34px 'Plus Jakarta Sans', system-ui";
        ctx.fillStyle = "#ffffff";
        const linesSub = wrapText(ctx, subtitle, textWidth);
        const lhSub = 36;
        for (const line of linesSub) {
          ctx.fillText(line, marginLeft, y);
          y += lhSub;
        }
      }

      ctx.globalAlpha = 1;
    }

    // Slide isi per halaman (beberapa baris, wrap + fade + wipe kiri→kanan)
    function drawBodyPage(pageIndex, t, sceneDur) {
      const W = canvas.width;
      const H = canvas.height;
      drawBaseBackground();

      const lines = bodyPages[pageIndex] || [];
      const marginLeft = 110;
      const marginRight = 140;
      const maxWidth = W - marginLeft - marginRight;

      // Durasi animasi
      const fadeInDur = 0.6;
      const wipeDur   = 0.8;   // durasi sapuan kiri→kanan
      const fadeOutDur = 0.5;

      // Hitung alpha (fade)
      let alpha = 1;
      if (t < fadeInDur) {
        alpha = t / fadeInDur;
      } else if (sceneDur - t < fadeOutDur) {
        alpha = (sceneDur - t) / fadeOutDur;
      }
      alpha = Math.max(0, Math.min(1, alpha));

      // Hitung wipe progress (0..1)
      let wipeProgress = 1;
      if (t < wipeDur) {
        wipeProgress = t / wipeDur;
      } else {
        wipeProgress = 1;
      }

      ctx.save();
      ctx.globalAlpha = alpha;

      // Clip dari kiri → kanan
      ctx.beginPath();
      ctx.rect(0, 0, marginLeft + maxWidth * wipeProgress, H);
      ctx.clip();

      ctx.textAlign = "left";
      ctx.font = "700 56px 'Plus Jakarta Sans', system-ui";

      let y = H - 600;
      const lineGap = 64;

      for (const rawLine of lines) {
        const text = rawLine.trimEnd();
        if (!text.trim()) {
          y += lineGap * 0.6;
          continue;
        }
        y = drawWrappedRichParagraph(
          ctx,
          text,
          marginLeft,
          y,
          maxWidth,
          lineGap,
          "#ffffff",
          "#ffffff",
          "#0088d8"
        );
      }

      ctx.restore();
      ctx.globalAlpha = 1;
    }

    // Pisah isi menjadi halaman berdasarkan baris kosong
    function rebuildBodyPages() {
      const body = bodyInput.value;
      const allLines = body.split("\n");

      bodyPages = [];
      let currentPage = [];

      for (let i = 0; i < allLines.length; i++) {
        const raw = allLines[i];
        const trimmed = raw.trimEnd();

        if (trimmed.trim() === "") {
          if (currentPage.length > 0) {
            bodyPages.push(currentPage.slice());
            currentPage = [];
          }
        } else {
          currentPage.push(trimmed);
        }
      }

      if (currentPage.length > 0) {
        bodyPages.push(currentPage);
      }

      if (bodyPages.length === 0) {
        bodyPages = [[]];
      }
    }

    // hitung total durasi berdasarkan panjang karakter per halaman
    function recomputeTargetDuration() {
      rebuildBodyPages();
      const pagesCount = bodyPages.length;

      pageDurations = [];

      // parameter kecepatan baca
      const basePerPage = 2.5;    // detik dasar per halaman
      const perChar = 0.035;      // detik tambahan per karakter
      const minDur = 3.0;         // min durasi per halaman
      const maxDur = 10.0;        // max durasi per halaman

      for (let i = 0; i < pagesCount; i++) {
        const lines = bodyPages[i];
        const text = lines.join(" ");
        const charCount = text.replace(/\s+/g, "").length;

        let dur = basePerPage + charCount * perChar;
        if (dur < minDur) dur = minDur;
        if (dur > maxDur) dur = maxDur;

        pageDurations.push(dur);
      }

      const titleTotal = TITLE_FADE_IN + TITLE_STATIC_AFTER;
      const isiTotal = pageDurations.reduce((a, b) => a + b, 0);
      targetDuration = titleTotal + GAP_AFTER_TITLE + isiTotal;
    }

    function drawFrame(globalT) {
      const pagesCount = bodyPages.length;
      const titleTotal = TITLE_FADE_IN + TITLE_STATIC_AFTER;
      const gapEnd = titleTotal + GAP_AFTER_TITLE;

      if (globalT <= titleTotal) {
        // fase judul
        drawSlide1(globalT, titleTotal);
      } else if (globalT <= gapEnd) {
        // jeda abu
        drawBaseBackground();
      } else {
        // fase isi
        const tIsi = globalT - gapEnd;
        const totalIsiDur = pageDurations.reduce((a, b) => a + b, 0);

        if (tIsi >= totalIsiDur) {
          // sudah lewat semua halaman, kunci di halaman terakhir
          const lastIndex = pagesCount - 1;
          const sceneDurLast = pageDurations[lastIndex] || 1;
          const tInPageLast = sceneDurLast - 0.0001;
          drawBodyPage(lastIndex, tInPageLast, sceneDurLast);
          return;
        }

        let acc = 0;
        let pageIndex = 0;
        while (pageIndex < pagesCount && tIsi >= acc + pageDurations[pageIndex]) {
          acc += pageDurations[pageIndex];
          pageIndex++;
        }

        if (pageIndex >= pagesCount) {
          pageIndex = pagesCount - 1;
        }

        const sceneDur = pageDurations[pageIndex] || 1;
        const tInPage = tIsi - acc;
        drawBodyPage(pageIndex, tInPage, sceneDur);
      }
    }

    function startPreview() {
      if (animating) return;
      recomputeTargetDuration();
      animating = true;
      startTime = performance.now();
      setStatus("preview");
      requestAnimationFrame(animate);
    }

    function animate(timestamp) {
      if (!animating && !recording) return;
      if (!startTime) startTime = timestamp;
      const elapsed = (timestamp - startTime) / 1000;
      const t = Math.min(elapsed, targetDuration);

      drawFrame(t);

      if (elapsed < targetDuration) {
        requestAnimationFrame(animate);
      } else {
        if (recording) {
          requestAnimationFrame(animate);
        } else {
          animating = false;
          setStatus("preview selesai");
        }
      }
    }

    function startRecording() {
      if (recording) return;
      recomputeTargetDuration();

      const stream = canvas.captureStream(30);
      recordedChunks = [];
      mediaRecorder = new MediaRecorder(stream, {
        mimeType: "video/webm;codecs=vp9",
      });

      mediaRecorder.ondataavailable = (e) => {
        if (e.data.size > 0) recordedChunks.push(e.data);
      };

      mediaRecorder.onstop = () => {
        const blob = new Blob(recordedChunks, { type: "video/webm" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "reels_output.webm";
        a.textContent = "Download video (WEBM)";
        a.style.color = "#38bdf8";
        a.style.textDecoration = "underline";

        downloadContainer.innerHTML = "";
        downloadContainer.appendChild(a);

        setStatus("render selesai");
        recording = false;
        stopBtn.disabled = true;
        recordBtn.disabled = false;
        previewBtn.disabled = false;
      };

      mediaRecorder.start();
      recording = true;
      setStatus("recording...");

      animating = true;
      startTime = performance.now();
      requestAnimationFrame(animate);

      setTimeout(() => {
        if (mediaRecorder && recording) {
          mediaRecorder.stop();
        }
      }, targetDuration * 1000);

      recordBtn.disabled = true;
      previewBtn.disabled = true;
      stopBtn.disabled = false;
    }

    function stopAll() {
      animating = false;
      if (mediaRecorder && recording) {
        mediaRecorder.stop();
      }
      recording = false;
      stopBtn.disabled = true;
      recordBtn.disabled = false;
      previewBtn.disabled = false;
      setStatus("dihentikan manual");
    }

    previewBtn.addEventListener("click", startPreview);
    recordBtn.addEventListener("click", startRecording);
    stopBtn.addEventListener("click", stopAll);

    if (document.fonts && document.fonts.ready) {
      document.fonts.ready.then(() => drawFrame(0));
    } else {
      drawFrame(0);
    }
  </script>
</body>
</html>
