<!DOCTYPE html>
<html lang="id">
<head>
  <meta charset="UTF-8">
  <title>Reels – Fast Light (Upper/Judul/Subjudul + Isi)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <!-- DM Serif Display hanya untuk Judul -->
  <link href="https://fonts.googleapis.com/css2?family=DM+Serif+Display&display=swap" rel="stylesheet">

  <style>
    * { box-sizing: border-box; }

    @font-face {
      font-family: 'PlusJakartaCustom';
      src: url('./fonts/PlusJakartaSans-Bold.woff2') format('woff2');
      font-weight: 700;
      font-style: normal;
      font-display: swap;
    }

    body {
      margin: 0;
      padding: 16px;
      display: flex;
      gap: 16px;
      background: #0f172a;
      color: #e5e7eb;
      font-family: 'PlusJakartaCustom', system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    }

    .panel {
      background: #020617;
      padding: 16px;
      border-radius: 12px;
      box-shadow: 0 12px 30px rgba(0,0,0,0.5);
    }
    .left {
      width: 360px;
      flex-shrink: 0;
    }
    .right {
      flex: 1;
      display: flex;
      justify-content: center;
      align-items: center;
    }
    h2 {
      margin: 0 0 6px 0;
      font-size: 18px;
    }
    small {
      font-size: 11px;
      color: #9ca3af;
    }
    .field { margin-top: 10px; }
    label {
      font-size: 13px;
      display: block;
      margin-bottom: 4px;
      color: #9ca3af;
    }
    textarea {
      width: 100%;
      min-height: 50px;
      background: #020617;
      color: #e5e7eb;
      border-radius: 8px;
      border: 1px solid #1f2937;
      padding: 8px 10px;
      font-size: 14px;
      resize: vertical;
      outline: none;
    }
    textarea:focus {
      border-color: #2563eb;
    }
    .btn-row {
      margin-top: 10px;
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }
    button {
      padding: 8px 16px;
      border-radius: 999px;
      border: none;
      cursor: pointer;
      font-size: 14px;
      font-weight: 500;
    }
    .btn-primary { background: #2563eb; color: #fff; }
    .btn-secondary { background: #111827; color: #e5e7eb; }
    .status {
      margin-top: 8px;
      font-size: 12px;
      color: #9ca3af;
    }
    #download { margin-top: 8px; font-size: 13px; }
    canvas {
      background: #808080;
      border-radius: 18px;
      border: 1px solid #4b5563;
      box-shadow: 0 20px 40px rgba(0,0,0,0.65);
      max-height: 92vh;
    }
  </style>
</head>
<body>
  <div class="panel left">
    <h2>Reels – Upper / Judul / Subjudul / Isi</h2>
    <small>
      Upper/Judul/Subjudul: muncul <b>statis 1 detik</b>, lalu <b>fade + sapu kiri→kanan</b>.<br>
      Isi: animasi <b>cepat ringan</b>, highlight [[...]] bergerak <b>per baris</b> (baris 1 dulu, lalu baris 2, dst).
    </small>
    <div class="field">
      <label>Upper</label>
      <textarea id="upper"></textarea>
    </div>
    <div class="field">
      <label>Judul</label>
      <textarea id="title"></textarea>
    </div>
    <div class="field">
      <label>Subjudul</label>
      <textarea id="subtitle"></textarea>
    </div>
    <div class="field">
      <label>Isi</label>
      <textarea id="body" placeholder="Pisah isi 1, isi 2, isi 3 dengan satu baris kosong.&#10;Gunakan [[highlight]] untuk menandai frasa penting."></textarea>
    </div>

    <div class="btn-row">
      <button class="btn-secondary" id="previewBtn">Preview</button>
      <button class="btn-primary" id="renderBtn">Render (WEBM)</button>
    </div>
    <div class="status" id="status">Status: idle</div>
    <div id="download"></div>
  </div>

  <div class="panel right">
    <canvas id="canvas" width="1080" height="1920"></canvas>
  </div>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

// ====== SISTEM KOORDINAT LOGIS + RENDER 2x UNTUK TAJAM & LEBIH TIPIS ======
const LOGICAL_WIDTH = 1080;
const LOGICAL_HEIGHT = 1920;
const SCALE = 2; // render di 2160x3840

canvas.width  = LOGICAL_WIDTH * SCALE;
canvas.height = LOGICAL_HEIGHT * SCALE;
// ukuran visual diatur oleh CSS (max-height), jadi tidak wajib set style.width/height
ctx.scale(SCALE, SCALE); // semua koordinat pakai sistem 1080x1920

const upperEl = document.getElementById('upper');
const titleEl = document.getElementById('title');
const subtitleEl = document.getElementById('subtitle');
const bodyEl = document.getElementById('body');
const previewBtn = document.getElementById('previewBtn');
const renderBtn = document.getElementById('renderBtn');
const statusEl = document.getElementById('status');
const downloadEl = document.getElementById('download');

let animating = false;
let recording = false;
let mediaRecorder = null;
let recordedChunks = [];
let startTime = null;
let targetDuration = 12;

let bodyPages = [];   // array halaman, tiap halaman = array string (paragraf)
let pageDurations = [];

// Judul timing
const TITLE_PRE_HOLD = 0.05;   // detik statis sebelum efek
const TITLE_FADE_IN  = 0.28;   // durasi fade
const TITLE_WIPE     = 0.35;   // durasi sapu kiri→kanan
const TITLE_STATIC   = 4.0;   // hold setelah animasi

// Isi timing (cepat ringan)
const BODY_FADE_IN   = 0.3;
const BODY_WIPE      = 0.4;
const BODY_FADE_OUT  = 0.5;   // tidak dipakai (fade-out dihapus)
const HIGHLIGHT_LINE_DUR = 0.8;  // durasi highlight per baris
const PAGE_GAP = 0.6; // jeda antar isi

function setStatus(t) {
  statusEl.textContent = 'Status: ' + t;
}

/**
 * wrapText:
 * - Menghormati line break manual (\n) dari textarea
 * - Tetap word-wrap otomatis per paragraf
 */
function wrapText(text, maxWidth) {
  const paragraphs = text.split(/\r?\n/);
  const lines = [];

  for (const para of paragraphs) {
    const trimmed = para.trim();
    if (!trimmed) {
      // baris kosong manual
      lines.push('');
      continue;
    }

    const words = trimmed.split(/\s+/);
    let line = words[0];

    for (let i = 1; i < words.length; i++) {
      const word = words[i];
      const testLine = line + ' ' + word;
      if (ctx.measureText(testLine).width > maxWidth) {
        lines.push(line);
        line = word;
      } else {
        line = testLine;
      }
    }
    lines.push(line);
  }

  return lines;
}

// Tokenize dengan [[highlight]]
function tokenizeHighlighted(text) {
  let tokens = [];
  let current = '';
  let inHighlight = false;
  let i = 0;
  function pushCurrent() {
    if (current.length > 0) {
      tokens.push({ text: current, highlight: inHighlight });
      current = '';
    }
  }
  while (i < text.length) {
    if (!inHighlight && text.startsWith('[[', i)) {
      pushCurrent();
      inHighlight = true;
      i += 2;
    } else if (inHighlight && text.startsWith(']]', i)) {
      pushCurrent();
      inHighlight = false;
      i += 2;
    } else {
      const ch = text[i];
      current += ch;
      if (ch === ' ') pushCurrent();
      i++;
    }
  }
  pushCurrent();
  return tokens;
}

// Gambar satu baris (visual line) dengan highlight kontinyu dan progress per baris
function drawLineFromTokens(tokens, x, y, normalColor, highlightColor, highlightBg, lineProgress) {
  if (lineProgress <= 0) {
    const full0 = tokens.map(t => t.text).join('');
    ctx.fillStyle = normalColor;
    ctx.fillText(full0, x, y);
    return;
  }
  if (lineProgress > 1) lineProgress = 1;

  let full = '';
  for (const t of tokens) full += t.text;

  let firstHi = null;
  let lastHi = null;
  let index = 0;
  for (const t of tokens) {
    const len = t.text.length;
    if (t.highlight && t.text.trim().length > 0) {
      if (firstHi === null) firstHi = index;
      lastHi = index + len;
    }
    index += len;
  }

  if (firstHi !== null && lastHi !== null) {
    const before = full.slice(0, firstHi);
    const inside = full.slice(firstHi, lastHi);
    const wBefore = ctx.measureText(before).width;
    const wInside = ctx.measureText(inside).width;
    const visible = wInside * lineProgress;
    const rectX = x + wBefore - 4;
    const rectY = y - 44;   // dinaikkan 2px
    const rectH = 58;       // lebih tinggi
    ctx.fillStyle = highlightBg;
    ctx.fillRect(rectX, rectY, visible + 8, rectH);
  }

  ctx.fillStyle = normalColor;
  ctx.fillText(full, x, y);
}

// Gambar paragraf dengan wrap, highlight per baris berurutan di seluruh halaman
function drawWrappedRichParagraph(text, x, yStart, maxWidth, lineGap, normalColor, highlightBg, globalLineIndexStart, timeForHighlight) {
  const tokens = tokenizeHighlighted(text);
  const linesTokens = [];
  let currentTokens = [];
  let currentText = '';

  for (const tok of tokens) {
    const test = currentText + tok.text;
    const w = ctx.measureText(test).width;
    if (currentText && w > maxWidth) {
      linesTokens.push(currentTokens);
      currentTokens = [tok];
      currentText = tok.text;
    } else {
      currentTokens.push(tok);
      currentText = test;
    }
  }
  if (currentTokens.length > 0) linesTokens.push(currentTokens);

  let y = yStart;
  let globalLineIndex = globalLineIndexStart;

  for (const lineTokens of linesTokens) {
    const lineStartT = globalLineIndex * HIGHLIGHT_LINE_DUR;
    const rel = (timeForHighlight - lineStartT) / HIGHLIGHT_LINE_DUR;
    const lineProgress = Math.max(0, Math.min(rel, 1));

    drawLineFromTokens(lineTokens, x, y, normalColor, normalColor, highlightBg, lineProgress);
    y += lineGap;
    globalLineIndex++;
  }

  return { y, linesUsed: linesTokens.length };
}

// Background
function drawBaseBackground() {
  ctx.fillStyle = '#808080';
  ctx.fillRect(0, 0, LOGICAL_WIDTH, LOGICAL_HEIGHT);
}

// Slide judul (Upper/Judul/Subjudul)
function drawTitleScene(t) {
  const W = LOGICAL_WIDTH;
  const H = LOGICAL_HEIGHT;
  drawBaseBackground();

  const upper = upperEl.value.trim();
  const title = titleEl.value.trim();
  const subtitle = subtitleEl.value.trim();

  const marginLeft = 110;
  const marginRight = 140;
  const textWidth = W - marginLeft - marginRight;
  let y = H - 700;  // dinaikkan agar Upper lebih tinggi

  const animCore = Math.max(TITLE_FADE_IN, TITLE_WIPE);

  let alpha = 1;
  let wipeProgress = 1;

  if (t < TITLE_PRE_HOLD) {
    alpha = 1;
    wipeProgress = 1;
  } else if (t < TITLE_PRE_HOLD + animCore) {
    const tAnim = t - TITLE_PRE_HOLD;
    if (tAnim <= TITLE_FADE_IN) {
      const p = Math.max(0, Math.min(tAnim / TITLE_FADE_IN, 1));
      const ease = p * p * (3 - 2 * p);
      alpha = ease;
    } else {
      alpha = 1;
    }
    if (tAnim <= TITLE_WIPE) {
      wipeProgress = Math.max(0, Math.min(tAnim / TITLE_WIPE, 1));
    } else {
      wipeProgress = 1;
    }
  } else {
    alpha = 1;
    wipeProgress = 1;
  }

  ctx.save();
  ctx.globalAlpha = alpha;
  ctx.beginPath();
  ctx.rect(0, 0, marginLeft + textWidth * wipeProgress, H);
  ctx.clip();
  ctx.textAlign = 'left';

  // Upper
  if (upper) {
    ctx.font = "700 34px 'PlusJakartaCustom'";
    ctx.fillStyle = '#ffffff';
    const linesUpper = wrapText(upper, textWidth);
    const lhUpper = 36;
    for (const line of linesUpper) {
      ctx.fillText(line, marginLeft, y);
      y += lhUpper;
    }
    y += 70; // jarak ekstra dari upper ke judul
  }

  // Judul
  if (title) {
    ctx.font = "400 100px 'DM Serif Display'";
    ctx.fillStyle = '#ffffff';
    const linesTitle = wrapText(title, textWidth);
    const lhTitle = 100;
    for (const line of linesTitle) {
      ctx.fillText(line, marginLeft, y);
      y += lhTitle;
    }
    y += -20; // jarak ke subjudul rapat
  }

  // Subjudul
  if (subtitle) {
    ctx.font = "700 34px 'PlusJakartaCustom'";
    ctx.fillStyle = '#ffffff';
    const linesSub = wrapText(subtitle, textWidth);
    const lhSub = 36;
    for (const line of linesSub) {
      ctx.fillText(line, marginLeft, y);
      y += lhSub;
    }
  }

  ctx.restore();
}

// Slide isi
function drawBodyPage(pageIndex, t, sceneDur) {
  const W = LOGICAL_WIDTH;
  const H = LOGICAL_HEIGHT;
  drawBaseBackground();

  const lines = bodyPages[pageIndex] || [];
  const marginLeft = 110;
  const marginRight = 140;
  const maxWidth = W - marginLeft - marginRight;

  let alpha = 1;
  if (t < BODY_FADE_IN) {
    alpha = t / BODY_FADE_IN;
  }
  alpha = Math.max(0, Math.min(1, alpha));

  let wipeProgress = 1;
  if (t < BODY_WIPE) {
    wipeProgress = t / BODY_WIPE;
  } else {
    wipeProgress = 1;
  }

  ctx.save();
  ctx.globalAlpha = alpha;
  ctx.beginPath();
  ctx.rect(0, 0, marginLeft + maxWidth * wipeProgress, H);
  ctx.clip();

  ctx.textAlign = 'left';
  ctx.font = "700 56px 'PlusJakartaCustom'";

  let y = H - 600;
  const lineGap = 64;
  let globalLineIndex = 0;

  for (const rawLine of lines) {
    const text = rawLine.trimEnd();
    if (!text.trim()) {
      y += lineGap * 0.6;
      continue;
    }
    const result = drawWrappedRichParagraph(
      text,
      marginLeft,
      y,
      maxWidth,
      lineGap,
      '#ffffff',
      '#0088d8',
      globalLineIndex,
      t   // waktu untuk highlight
    );
    y = result.y;
    globalLineIndex += result.linesUsed;
  }

  ctx.restore();
}

// =========================
// ANTI-ORPHAN KHUSUS ISI
// =========================
function fixOrphansInBodyLine(line) {
  // "ke" / "di" + kata setelahnya → pakai non-breaking space
  line = line.replace(/\b(ke|di)\s+(?=\S)/gi, (match, p1) => {
    return p1 + '\u00A0'; // \u00A0 = non-breaking space
  });

  // "terima kasih"
  line = line.replace(/\b(terima)\s+(kasih)\b/gi, (match, a, b) => {
    return a + '\u00A0' + b;
  });

  // "Jawa Pos"
  line = line.replace(/\b(Jawa)\s+(Pos)\b/gi, (match, a, b) => {
    return a + '\u00A0' + b;
  });

  return line;
}

// Bangun halaman isi dari textarea (dengan anti-orphan)
function rebuildBodyPages() {
  const allLines = bodyEl.value.split('\n');
  bodyPages = [];
  let current = [];
  for (const raw of allLines) {
    const trimmed = raw.trimEnd();
    if (!trimmed.trim()) {
      if (current.length > 0) {
        bodyPages.push(current.slice());
        current = [];
      }
    } else {
      // terapkan anti-orphan KHUSUS isi
      const fixedLine = fixOrphansInBodyLine(trimmed);
      current.push(fixedLine);
    }
  }
  if (current.length > 0) bodyPages.push(current);
  if (bodyPages.length === 0) bodyPages = [[]];
}

// Hitung durasi total (termasuk jeda antar isi)
function recomputeTargetDuration() {
  rebuildBodyPages();
  pageDurations = [];
  for (const page of bodyPages) {
    const text = page.join(' ').replace(/\s+/g, '');
    const charCount = text.length;
    let d = 2.5 + charCount * 0.035;
    if (d < 3) d = 3;
    if (d > 10) d = 10;
    pageDurations.push(d);
  }
  const animCore = Math.max(TITLE_FADE_IN, TITLE_WIPE);
  const titleTotal = TITLE_PRE_HOLD + animCore + TITLE_STATIC;

  const isiDurNoGap = pageDurations.reduce((a, b) => a + b, 0);
  const gapDur = PAGE_GAP * Math.max(0, bodyPages.length - 1);
  const isiTotal = isiDurNoGap + gapDur;

  targetDuration = titleTotal + 1.0 + isiTotal; // +1s gap setelah judul
}

// Gambar frame berdasarkan waktu global
function drawFrame(globalT) {
  const animCore = Math.max(TITLE_FADE_IN, TITLE_WIPE);
  const titleTotal = TITLE_PRE_HOLD + animCore + TITLE_STATIC;
  const gapEnd = titleTotal + 1.0;

  if (globalT <= titleTotal) {
    drawTitleScene(globalT);
    return;
  }
  if (globalT <= gapEnd) {
    drawBaseBackground();
    return;
  }

  const tIsi = globalT - gapEnd;
  let acc = 0;

  for (let i = 0; i < bodyPages.length; i++) {
    const d = pageDurations[i];
    const blockEnd = acc + d;

    // fase tampilan isi
    if (tIsi < blockEnd) {
      const tInPage = tIsi - acc;
      drawBodyPage(i, tInPage, d);
      return;
    }

    // fase jeda setelah halaman ini
    if (tIsi < blockEnd + PAGE_GAP) {
      drawBaseBackground();  // tampilan kosong saat jeda
      return;
    }

    acc = blockEnd + PAGE_GAP; // lanjut ke halaman berikutnya
  }

  const lastIndex = bodyPages.length - 1;
  const lastDur = pageDurations[lastIndex] || 1;
  drawBodyPage(lastIndex, lastDur - 0.001, lastDur);
}

// Animasi
let animStart = null;
function animate(ts) {
  if (!animating && !recording) return;
  if (!animStart) animStart = ts;
  const elapsed = (ts - animStart) / 1000;
  const t = Math.min(elapsed, targetDuration);
  drawFrame(t);
  if (elapsed < targetDuration) {
    requestAnimationFrame(animate);
  } else {
    if (recording) {
      requestAnimationFrame(animate);
    } else {
      animating = false;
      setStatus('preview selesai');
    }
  }
}

// Preview
previewBtn.addEventListener('click', () => {
  recomputeTargetDuration();
  animating = true;
  recording = false;
  animStart = null;
  setStatus('preview');
  requestAnimationFrame(animate);
});

// Render WEBM
renderBtn.addEventListener('click', () => {
  recomputeTargetDuration();
  const stream = canvas.captureStream(30); // akan capture 2160x3840
  recordedChunks = [];
  mediaRecorder = new MediaRecorder(stream, { mimeType: 'video/webm;codecs=vp9' });

  mediaRecorder.ondataavailable = (e) => {
    if (e.data.size > 0) recordedChunks.push(e.data);
  };
  mediaRecorder.onstop = () => {
    const blob = new Blob(recordedChunks, { type: 'video/webm' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'reels_output.webm';
    a.textContent = 'Download video (WEBM)';
    a.style.color = '#38bdf8';
    a.style.textDecoration = 'underline';
    downloadEl.innerHTML = '';
    downloadEl.appendChild(a);
    setStatus('render selesai');
    recording = false;
  };

  mediaRecorder.start();
  recording = true;
  animating = true;
  animStart = null;
  setStatus('rendering...');

  requestAnimationFrame(animate);

  setTimeout(() => {
    if (recording && mediaRecorder) mediaRecorder.stop();
  }, targetDuration * 1000 + 500);
});

// Draw first frame
if (document.fonts && document.fonts.ready) {
  document.fonts.ready.then(() => drawFrame(0));
} else {
  drawFrame(0);
}
</script>
</body>
</html>
